线程池的简单实现
1 线程 2 池 
池的实现，列表
对象：线程
对象的获取 和 归还
获取对象时，判断当前的是否可用
判断池中是否有可用的对象
如果池中没有对象可用，是否创建新的对象。

Queue 维护线程池

runnable 和 Thread 的区别
实现runnable ， 只是实现了线程的方法体，执行run方法的话，那么和执行一般的方法没有不同，是按照顺序执行的。
继承Thread ，执行Thread的start方法，才能真正发挥线程的作用。

demo弊端：任务是一个一个添加的，所以线程执行任务只能一个一个执行
这是一个失败的线程池。


优化思路：
Pthread 线程池中的线程对象
Queue<PThread> 线程池
初始化线程池，然后启动线程池中的线程。池中的线程在一个循环体中，如果有任务就回去执行任务，否则wait。
ThreadPool 线程池对象，能够初始化线程池 和 获取线程池中的线程对象。 开始初始化一定数量的线程对象放入池中，然后
去处理task，执行完task的线程返回pool中。
获取pool中PThread：如果线程池中还有可用的对象，那么获取成功，否则wait
返回pool    PThread：返回用完的对象，然后notifyall，唤醒等待的线程。
问题所在：池中对象会不停的等待task ，处于wait状态。获取pool对象，如果pool为空，那么也wait。

wait 的用法：线程的话，才能有wait等待,而一般的方法是不能用wait的。试验3 Test3。

在获取池中对象和返回对象的时候，不能乱用wait和notify。但是又必须能够实现这种效果。那么观察者模式是否可以生效呢？

观察者模式：
角色：观察者 ， 被观察者 ，Main  ， 观察者接口 ， 被观察者接口
被观察者：返回对象到池的动作，通知观察者。
观察者：获取对象

不知道如何嵌入啊

最后虽然实现了，但是觉得不是很好。思路清理：
1：初始化n个线程到线程池，并且启动这些线程。这些线程启动后会执行任务，如果任务为空的话则等待任务的到来，
	并且归还线程到池中。
2：初始化任务，并且唤醒等待执行任务的线程。从池中获取线程去执行这些任务。
3：获取线程：如果池为空，那么等待，等待归还线程后去唤醒。
4：归还线程：用完线程后就去归还，然后唤醒等待这个线程的对象。

注意点：（关键点）
1：池的构造是：ConcurrentLinkedQueue ， 支持多线程
2：池对象：单例模式，在对池对象的操作都是同一个池对象。
3：池中对象：Pthread extends Thread 。继承线程，并且能够添加任务去处理任务。
4：对池中对象的获取和归还，都必须是同步的。因为添加了getInstance().wait() 和 getInstance().notify() , 如果不同步，那么
	报错。线程处理状态异常。
	
过程如线程池流程图	
问题追踪：
模拟流程图过程：
1：池中有3个对象 a , b , c 
2：10个任务 0,1,2,3,4,5,6,7,8,9
3：开始 
4：初始化池pool，池对象  a,b,c
5：a 发现没任务，返回pool waita ， b发现没任务 返回pool waitb，c发现没任务 返回pool waitc
	abc都处于wait状态。但是它们都处于一个while( true ) 循环当中，一旦有任务就会被notify
	while( true ) a handle( task ), wait()  ; while( true ) b handle( task ), wait() ; while( true ) c handle( task ), wait() ;
6：初始化1个任务对象，a被唤醒，a去处理任务时可能第2个任务来了，b被唤醒，为了简便理解,理解为：

线程a,b,c 为3个工人 a,b,c ; 线程池为 工人的帐篷，任务为货车。
工人：只会工作和休息。
a,b,c 3人来到工厂，发现任务没来，则回到帐篷休息。
货车来了，abc都被唤醒。
a 拿走了0，正在处理0的时候， 
b拿走了1，正在处理1的时候，
c拿走了2，正在处理2的时候，

abc都在运货物的路上，而此时需要搬运的货物还在增多... 货物囤积了3,4,5....
囤积的货物需要工人来搬运，但是此时并没有空闲的工人，因此第3个货物处于等待工人的状态

a处理结束，会回到囤积区，然后（唤醒等待的货物3）搬运囤积的货物3。
a拿走了3，正在处理的时候...

注意：货车上面虽然有100个货物，但是只有在工人满足的情况下才会把货物卸下给工人去搬运，如果工人没有空闲的，
	也只会准备1个货物处于等待的状态，而其他的货物可以理解为还没有制造完成。
	这个处于等待状态的货物，会等待着工人空闲的时候把它唤醒，然后把这个货物取走。
	
代码理解为：初始化线程的时候，会看是否有任务，没有则返回池中。
任务来了之后，池中对象处理任务，刚开始，池中有几个对象就会处理几个任务，然后没有空闲的池中对象。
任务会有一条处于等待处理的状态。
池中对象处理完任务之后，返回池中，唤醒处于等待处理状态的任务，然后去处理这个任务。
任务有了之后，会唤醒此时正处于空闲的池中对象，让它去处理任务。
池中对象  	返回池中   唤醒一条正处于等待状态的任务，然后就去wait
任务有了		唤醒此时空闲的池中对象		池中对象去处理这个任务

那么就不存在新来的任务堆积的问题，因为这些任务会只会有一条处于等待的状态。


			        



