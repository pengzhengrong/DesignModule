保存暂停模式：
Request 对象，请求对象
RequestQueue：请求队列，用来存放请求的队列，定义了添加请求和获取请求方法。
ServerThread：在构造函数中维护了请求队列和服务线程，在获取请求后则可处理请求。
ClientThread：在构造函数中维护了请求队列和客户线程，主要是为了模拟用户发出请求然后添加到请求队列。
Test：测试，先初始化一个请求队列，然后启动服务进程，再开启客户端进程。

然而，这个简单的demo模式，却不能获取服务器处理后的请求结果。因为无法得知什么时候处理，何时处理结束。
但是巧妙的结合future模式，那么就可以获取返回的结果了。

回忆future：
jdk Future：
RealData implements Callable {
	//实现call方法，主要的逻辑表达处理
}

main{
	//任务队列，用来存放任务
	//启动线程，用来处理任务队列中的任务，并且实现其中的call方法。
	//获取返回的结果，如果没有处理完那么一直处于等待状态，直到处理结束。
}

结合思路猜想：
1：客户端请求实现Callable接口，然后加入任务队列中。
	（1）任务队列：保存停留模式中有任务队列，future模式中也有一个任务队列。
2：客户端请求操作，服务器响应客户请求，中间以请求队列作为缓存。	
3：角色：request，requestQueue，clientThread，serviceThread，realData
	
	
实现：
Request{
	
}