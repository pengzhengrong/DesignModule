# DesignModule
一：对于设计模式的理解
 1：设计模式，是前人对于一些常见问题的总结。是处理某一中问题智慧的结晶。所以，我们后人更应该好好的理解设计模式的优点，在项目中善于利用。在性能方面，如果选择好一个设计模式胜于代码的优化。

二：设计模式
 1：单例模式
 理解：单例模式，在对象被普遍初始化的情况下，特别对于重量级的初始化，单例是很好的。
 代码：见单例模式
 角色：单例类，使用者 
 疑问： 
 （1）main方法中，实例化2个单例对象s1,s2, s1==s2 true 
 （2）启动2个线程，线程内分别初始化单例，只有一个线程初始化了。 
 用处：维护公共资源，配置文件的读取 
 2：代理模式 
 理解：请求者请求真实主题，但是却没有实际运用到里面的业务，因此不需要实例化真实主题。因此。这个时候可以利用代理模式，代理模式中不处理任何逻辑，如果用户真的需要处理代理在请求真实主题。 
 解决问题：如果大量用户直接访问主题，那么会消耗大量的内存，因此使得服务器响应的时间变得很长。但是用户可能并非调用了主题内的逻辑方法，因此根本不需要i实例化一些不需要的对象。 
 代理类型：动态代理，静态代理 
 经典案例：hibernate的属性延迟加载和关联表的延时加载 
 动态代理类型：
 （1）JDK自带的动态代理 
 （2）CGLIB 
 （3）javaassist：实现方式有2种，1是使用代理工厂创建，2是动态代码创建
 3：享元模式 
 理解：一个系统中存在多个共同的对象，那么可以把这个对象设定为共享的对象。这样只需要实例化一次就能供系统共享。 
 特性：设计模式中为数不多主要目的是为了提高性能的模式 
 角色：享元工厂，抽象享元，具体享元类，main 
 举例：A，B，C 三个公司租用一个系统，每个公司分别100人，那么定义3个享元即可提供这300人分别查询自己的工资情况。 
 4：装饰者模式 
 理解：动态添加对象功能，继承是一个紧耦合，而如果使用委托，那么只要接口不变就是松耦合。基本设计原则有一条叫做合成/聚合复用原则。通过委托，复用系统中各个组件，运行时将这些功能组件进行叠加，从而够造成一个超级对象。 
 角色：组件接口，具体组件，装饰者，具体装饰者 
 经典案例：java I/O  
 代码：git@github.com:pengzhengrong/DesignModule.git 
 5：master-worker 模式 
 实例：数据自动清洗的数据插入操作 
 角色：Master，Worker，main
 理解：线程同步操作的经典模式。Master线程获取任务，并且分发Worker线程处理。处理的结果返回Master。主从线程是异步操作的。 
  Master：主人，主人不会去干活，把活都交给工人来干。主人只需要接活，然后把活分配给工人去干。所以Master需要定义那些东西呢？  
  工人（threadMap），任务（workQueue），最后的结果（resultMap），工人是否都已经干完了（iscomplete），分配执行任务（execute），通知工人有活干（初始化的时候通知） 
 Worker：工人，工人主要就是干活，所以需要定义的有：什么活（workQueue），干的结果（resultMap），怎么去干（handle），执行任务（run） 
 扩展思路：Master 有各种各样的工人，Master可以接受相应的不同的任务分配给不同的类型的工人去处理。 
 代码：git@github.com:pengzhengrong/DesignModule.git 
 6：观察者模式
 	理解：对于需要不断监听的功能实现，观察者模式是一个很好的实现方式。
 	经典案例：button的触发事件。
 	角色：主题接口，具体接口，观察者接口，具体观察者
 	代码：见git
 7：	池对象
 	理解：一次性创建多个对象，把对象放入一个池中，调用对象的话就可以直接从池中获取，而无需创建。
 	案例：数据库连接池
 	接口：已经实现的接口：StackObjectPool，GenericObjectPool , SoftReferenceObjectPool
 	角色：对象 ， 对象池 ， main
 	实现：
 		（1）创建一个对象，而且这个对象内部不能实例化自己。
 		（2）将对象加入对象池当中，需要实现上述3个方法中的一种作为对象池的实现。
 8：Future模式
 	理解：以往，客户端请求服务器，必须等待服务器的应答之后才会去处理其他的事情。现在，客户端请求服务器，客户端并不需要一直等待服务器的应答，服务器可以给客户端一个暂时的数据，然后客户端去处理其他的事情，等服务器将结果返回的时候，在去处理这个数据。
 	经典案例：
 	角色：Main，Client，Data（返回数据的接口），FutureData（Future数据，构造很快，是一个虚拟数据，但是需要装配RealData），RealData（真实数据，构造比较慢）
 	代码：见git
 	举例：客户淘宝下完订单，店家只是获取了订单但是可能并不会立马去处理订单，而是过一段时间在去处理，并且期间店家
 				还可以处理其他的事情。
 9：Guarded Suspension 模式
 	理解：保护暂停模式
 	举例：服务进程准备好时才能处理请求，但是此时过多的请求服务进程很短时间内难以承受，有不能丢弃任何一个请求，此
 				时保护暂停模式则发挥巨大的作用。将客户请求放入队列中，然后服务进程一个个的处理。
 	




